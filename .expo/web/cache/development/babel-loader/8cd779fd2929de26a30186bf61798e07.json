{"ast":null,"code":"'use strict';\n\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/franckcaget/Hedia/frosty/node_modules/react-native-swipeable-list/Swipeable/SwipeableRow.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nvar IS_RTL = I18nManager.isRTL;\nvar CLOSED_LEFT_POSITION = 0;\nvar HORIZONTAL_SWIPE_DISTANCE_THRESHOLD = 10;\nvar HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD = 0.3;\nvar SLOW_SPEED_SWIPE_FACTOR = 4;\nvar SWIPE_DURATION = 300;\nvar ON_MOUNT_BOUNCE_DELAY = 700;\nvar ON_MOUNT_BOUNCE_DURATION = 400;\nvar RIGHT_SWIPE_BOUNCE_BACK_DISTANCE = 30;\nvar RIGHT_SWIPE_BOUNCE_BACK_DURATION = 300;\nvar RIGHT_SWIPE_THRESHOLD = 30 * SLOW_SPEED_SWIPE_FACTOR;\nvar DEFAULT_SWIPE_THRESHOLD = 30;\n\nvar emptyFunction = function emptyFunction() {};\n\nvar SwipeableRow = function (_React$Component) {\n  _inherits(SwipeableRow, _React$Component);\n\n  var _super = _createSuper(SwipeableRow);\n\n  function SwipeableRow() {\n    var _this;\n\n    _classCallCheck(this, SwipeableRow);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _this._handleMoveShouldSetPanResponderCapture = function (event, gestureState) {\n      return gestureState.dy < 10 && _this._isValidSwipe(gestureState);\n    };\n\n    _this._handlePanResponderGrant = function (event, gestureState) {};\n\n    _this._handlePanResponderMove = function (event, gestureState) {\n      if (_this._isSwipingExcessivelyRightFromClosedPosition(gestureState)) {\n        return;\n      }\n\n      _this.props.onSwipeStart && _this.props.onSwipeStart();\n\n      if (_this._isSwipingRightFromClosed(gestureState)) {\n        _this._swipeSlowSpeed(gestureState);\n      } else {\n        _this._swipeFullSpeed(gestureState);\n      }\n    };\n\n    _this._onPanResponderTerminationRequest = function (event, gestureState) {\n      return false;\n    };\n\n    _this._handlePanResponderEnd = function (event, gestureState) {\n      var horizontalDistance = IS_RTL ? -gestureState.dx : gestureState.dx;\n\n      if (_this._isSwipingRightFromClosed(gestureState)) {\n        _this.props.onOpen && _this.props.onOpen();\n\n        _this._animateBounceBack(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n      } else if (_this._shouldAnimateRemainder(gestureState)) {\n        if (horizontalDistance < 0) {\n          _this.props.onOpen && _this.props.onOpen();\n\n          _this._animateToOpenPositionWith(gestureState.vx, horizontalDistance);\n        } else {\n          _this.props.onClose && _this.props.onClose();\n\n          _this._animateToClosedPosition();\n        }\n      } else {\n        if (_this._previousLeft === CLOSED_LEFT_POSITION) {\n          _this._animateToClosedPosition();\n        } else {\n          _this._animateToOpenPosition();\n        }\n      }\n\n      _this.props.onSwipeEnd && _this.props.onSwipeEnd();\n    };\n\n    _this._panResponder = PanResponder.create({\n      onMoveShouldSetPanResponderCapture: _this._handleMoveShouldSetPanResponderCapture,\n      onPanResponderGrant: _this._handlePanResponderGrant,\n      onPanResponderMove: _this._handlePanResponderMove,\n      onPanResponderRelease: _this._handlePanResponderEnd,\n      onPanResponderTerminationRequest: _this._onPanResponderTerminationRequest,\n      onPanResponderTerminate: _this._handlePanResponderEnd,\n      onShouldBlockNativeResponder: function onShouldBlockNativeResponder(event, gestureState) {\n        return false;\n      }\n    });\n    _this._previousLeft = CLOSED_LEFT_POSITION;\n    _this._timeoutID = null;\n    _this.state = {\n      currentLeft: new Animated.Value(_this._previousLeft),\n      isSwipeableViewRendered: false,\n      rowHeight: null\n    };\n\n    _this._onSwipeableViewLayout = function (event) {\n      _this.setState({\n        isSwipeableViewRendered: true,\n        rowHeight: event.nativeEvent.layout.height\n      });\n    };\n\n    _this._animateToClosedPositionDuringBounce = function () {\n      _this._animateToClosedPosition(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n    };\n\n    return _this;\n  }\n\n  _createClass(SwipeableRow, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      if (this.props.shouldBounceOnMount) {\n        this._timeoutID = setTimeout(function () {\n          _this2._animateBounceBack(ON_MOUNT_BOUNCE_DURATION);\n        }, ON_MOUNT_BOUNCE_DELAY);\n      }\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      var _this$props$isOpen, _nextProps$isOpen;\n\n      var isOpen = (_this$props$isOpen = this.props.isOpen) != null ? _this$props$isOpen : false;\n      var nextIsOpen = (_nextProps$isOpen = nextProps.isOpen) != null ? _nextProps$isOpen : false;\n\n      if (isOpen && !nextIsOpen) {\n        this._animateToClosedPosition();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._timeoutID != null) {\n        clearTimeout(this._timeoutID);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var slideOutView;\n\n      if (this.state.isSwipeableViewRendered && this.state.rowHeight) {\n        slideOutView = React.createElement(View, {\n          style: [styles.slideOutContainer, {\n            height: this.state.rowHeight\n          }],\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 184,\n            columnNumber: 17\n          }\n        }, this.props.slideoutView);\n      }\n\n      var swipeableView = React.createElement(Animated.View, {\n        onLayout: this._onSwipeableViewLayout,\n        style: {\n          transform: [{\n            translateX: this.state.currentLeft\n          }]\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 192,\n          columnNumber: 13\n        }\n      }, this.props.children);\n      return React.createElement(View, _extends({}, this._panResponder.panHandlers, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 201,\n          columnNumber: 13\n        }\n      }), slideOutView, swipeableView);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.props.onClose && this.props.onClose();\n\n      this._animateToClosedPosition();\n    }\n  }, {\n    key: \"_isSwipingRightFromClosed\",\n    value: function _isSwipingRightFromClosed(gestureState) {\n      var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n      return this._previousLeft === CLOSED_LEFT_POSITION && gestureStateDx > 0;\n    }\n  }, {\n    key: \"_swipeFullSpeed\",\n    value: function _swipeFullSpeed(gestureState) {\n      this.state.currentLeft.setValue(this._previousLeft + gestureState.dx);\n    }\n  }, {\n    key: \"_swipeSlowSpeed\",\n    value: function _swipeSlowSpeed(gestureState) {\n      this.state.currentLeft.setValue(this._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR);\n    }\n  }, {\n    key: \"_isSwipingExcessivelyRightFromClosedPosition\",\n    value: function _isSwipingExcessivelyRightFromClosedPosition(gestureState) {\n      var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n      return this._isSwipingRightFromClosed(gestureState) && gestureStateDx > RIGHT_SWIPE_THRESHOLD;\n    }\n  }, {\n    key: \"_animateTo\",\n    value: function _animateTo(toValue) {\n      var _this3 = this;\n\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SWIPE_DURATION;\n      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : emptyFunction;\n      Animated.timing(this.state.currentLeft, {\n        duration: duration,\n        toValue: toValue,\n        useNativeDriver: true\n      }).start(function () {\n        _this3._previousLeft = toValue;\n        callback();\n      });\n    }\n  }, {\n    key: \"_animateToOpenPosition\",\n    value: function _animateToOpenPosition() {\n      var _this$props$maxSwipeD;\n\n      var maxSwipeDistance = (_this$props$maxSwipeD = this.props.maxSwipeDistance) != null ? _this$props$maxSwipeD : 0;\n      var directionAwareMaxSwipeDistance = IS_RTL ? -maxSwipeDistance : maxSwipeDistance;\n\n      this._animateTo(-directionAwareMaxSwipeDistance);\n    }\n  }, {\n    key: \"_animateToOpenPositionWith\",\n    value: function _animateToOpenPositionWith(speed, distMoved) {\n      var _this$props$maxSwipeD2;\n\n      speed = speed > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD ? speed : HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;\n      var maxSwipeDistance = (_this$props$maxSwipeD2 = this.props.maxSwipeDistance) != null ? _this$props$maxSwipeD2 : 0;\n      var duration = Math.abs((maxSwipeDistance - Math.abs(distMoved)) / speed);\n      var directionAwareMaxSwipeDistance = IS_RTL ? -maxSwipeDistance : maxSwipeDistance;\n\n      this._animateTo(-directionAwareMaxSwipeDistance, duration);\n    }\n  }, {\n    key: \"_animateToClosedPosition\",\n    value: function _animateToClosedPosition() {\n      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SWIPE_DURATION;\n\n      this._animateTo(CLOSED_LEFT_POSITION, duration);\n    }\n  }, {\n    key: \"_animateBounceBack\",\n    value: function _animateBounceBack(duration) {\n      var swipeBounceBackDistance = IS_RTL ? -RIGHT_SWIPE_BOUNCE_BACK_DISTANCE : RIGHT_SWIPE_BOUNCE_BACK_DISTANCE;\n\n      this._animateTo(-swipeBounceBackDistance, duration, this._animateToClosedPositionDuringBounce);\n    }\n  }, {\n    key: \"_isValidSwipe\",\n    value: function _isValidSwipe(gestureState) {\n      var _this$props$preventSw;\n\n      var preventSwipeRight = (_this$props$preventSw = this.props.preventSwipeRight) != null ? _this$props$preventSw : false;\n\n      if (preventSwipeRight && this._previousLeft === CLOSED_LEFT_POSITION && gestureState.dx > 0) {\n        return false;\n      }\n\n      return Math.abs(gestureState.dx) > HORIZONTAL_SWIPE_DISTANCE_THRESHOLD;\n    }\n  }, {\n    key: \"_shouldAnimateRemainder\",\n    value: function _shouldAnimateRemainder(gestureState) {\n      var _this$props$swipeThre;\n\n      var swipeThreshold = (_this$props$swipeThre = this.props.swipeThreshold) != null ? _this$props$swipeThre : DEFAULT_SWIPE_THRESHOLD;\n      return Math.abs(gestureState.dx) > swipeThreshold || gestureState.vx > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;\n    }\n  }]);\n\n  return SwipeableRow;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  slideOutContainer: {\n    bottom: 0,\n    left: 0,\n    position: 'absolute',\n    right: 0,\n    top: 0\n  }\n});\nexport default SwipeableRow;","map":{"version":3,"sources":["/Users/franckcaget/Hedia/frosty/node_modules/react-native-swipeable-list/Swipeable/SwipeableRow.js"],"names":["React","IS_RTL","I18nManager","isRTL","CLOSED_LEFT_POSITION","HORIZONTAL_SWIPE_DISTANCE_THRESHOLD","HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD","SLOW_SPEED_SWIPE_FACTOR","SWIPE_DURATION","ON_MOUNT_BOUNCE_DELAY","ON_MOUNT_BOUNCE_DURATION","RIGHT_SWIPE_BOUNCE_BACK_DISTANCE","RIGHT_SWIPE_BOUNCE_BACK_DURATION","RIGHT_SWIPE_THRESHOLD","DEFAULT_SWIPE_THRESHOLD","emptyFunction","SwipeableRow","_handleMoveShouldSetPanResponderCapture","event","gestureState","dy","_isValidSwipe","_handlePanResponderGrant","_handlePanResponderMove","_isSwipingExcessivelyRightFromClosedPosition","props","onSwipeStart","_isSwipingRightFromClosed","_swipeSlowSpeed","_swipeFullSpeed","_onPanResponderTerminationRequest","_handlePanResponderEnd","horizontalDistance","dx","onOpen","_animateBounceBack","_shouldAnimateRemainder","_animateToOpenPositionWith","vx","onClose","_animateToClosedPosition","_previousLeft","_animateToOpenPosition","onSwipeEnd","_panResponder","PanResponder","create","onMoveShouldSetPanResponderCapture","onPanResponderGrant","onPanResponderMove","onPanResponderRelease","onPanResponderTerminationRequest","onPanResponderTerminate","onShouldBlockNativeResponder","_timeoutID","state","currentLeft","Animated","Value","isSwipeableViewRendered","rowHeight","_onSwipeableViewLayout","setState","nativeEvent","layout","height","_animateToClosedPositionDuringBounce","shouldBounceOnMount","setTimeout","nextProps","isOpen","nextIsOpen","clearTimeout","slideOutView","styles","slideOutContainer","slideoutView","swipeableView","transform","translateX","children","panHandlers","gestureStateDx","setValue","toValue","duration","callback","timing","useNativeDriver","start","maxSwipeDistance","directionAwareMaxSwipeDistance","_animateTo","speed","distMoved","Math","abs","swipeBounceBackDistance","preventSwipeRight","swipeThreshold","Component","StyleSheet","bottom","left","position","right","top"],"mappings":"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","sourcesContent":["'use strict';\n\nimport React from 'react';\nimport { Animated, I18nManager, PanResponder, StyleSheet, View } from 'react-native';\n\n// import type { LayoutEvent, PressEvent } from 'CoreEventTypes';\n// import type { GestureState } from 'PanResponder';\n\nconst IS_RTL = I18nManager.isRTL;\n\n// NOTE: Eventually convert these consts to an input object of configurations\n\n// Position of the left of the swipable item when closed\nconst CLOSED_LEFT_POSITION = 0;\n// Minimum swipe distance before we recognize it as such\nconst HORIZONTAL_SWIPE_DISTANCE_THRESHOLD = 10;\n// Minimum swipe speed before we fully animate the user's action (open/close)\nconst HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD = 0.3;\n// Factor to divide by to get slow speed; i.e. 4 means 1/4 of full speed\nconst SLOW_SPEED_SWIPE_FACTOR = 4;\n// Time, in milliseconds, of how long the animated swipe should be\nconst SWIPE_DURATION = 300;\n\n/**\n * On SwipeableListView mount, the 1st item will bounce to show users it's\n * possible to swipe\n */\nconst ON_MOUNT_BOUNCE_DELAY = 700;\nconst ON_MOUNT_BOUNCE_DURATION = 400;\n\n// Distance left of closed position to bounce back when right-swiping from closed\nconst RIGHT_SWIPE_BOUNCE_BACK_DISTANCE = 30;\nconst RIGHT_SWIPE_BOUNCE_BACK_DURATION = 300;\n/**\n * Max distance of right swipe to allow (right swipes do functionally nothing).\n * Must be multiplied by SLOW_SPEED_SWIPE_FACTOR because gestureState.dx tracks\n * how far the finger swipes, and not the actual animation distance.\n */\nconst RIGHT_SWIPE_THRESHOLD = 30 * SLOW_SPEED_SWIPE_FACTOR;\nconst DEFAULT_SWIPE_THRESHOLD = 30;\n\nconst emptyFunction = () => {};\n\n// type Props = $ReadOnly<{|\n//     children?: ?React.Node,\n//     isOpen?: ?boolean,\n//     maxSwipeDistance?: ?number,\n//     onClose?: ?() => void,\n//     onOpen?: ?() => void,\n//     onSwipeEnd?: ?() => void,\n//     onSwipeStart?: ?() => void,\n//     preventSwipeRight?: ?boolean,\n//     shouldBounceOnMount?: ?boolean,\n//     slideoutView?: ?React.Node,\n//     swipeThreshold?: ?number,\n// |}>;\n\n// type State = {\n//     currentLeft: Animated.Value,\n//     isSwipeableViewRendered: boolean,\n//     rowHeight: ?number,\n// };\n\n/**\n * Creates a swipable row that allows taps on the main item and a custom View\n * on the item hidden behind the row. Typically this should be used in\n * conjunction with SwipeableListView for additional functionality, but can be\n * used in a normal ListView. See the renderRow for SwipeableListView to see how\n * to use this component separately.\n */\nclass SwipeableRow extends React.Component {\n    _handleMoveShouldSetPanResponderCapture = (event, gestureState) => {\n        // Decides whether a swipe is responded to by this component or its child\n        return gestureState.dy < 10 && this._isValidSwipe(gestureState);\n    };\n\n    _handlePanResponderGrant = (event, gestureState) => {};\n\n    _handlePanResponderMove = (event, gestureState) => {\n        if (this._isSwipingExcessivelyRightFromClosedPosition(gestureState)) {\n            return;\n        }\n\n        this.props.onSwipeStart && this.props.onSwipeStart();\n\n        if (this._isSwipingRightFromClosed(gestureState)) {\n            this._swipeSlowSpeed(gestureState);\n        } else {\n            this._swipeFullSpeed(gestureState);\n        }\n    };\n\n    _onPanResponderTerminationRequest = (event, gestureState) => {\n        return false;\n    };\n\n    _handlePanResponderEnd = (event, gestureState) => {\n        const horizontalDistance = IS_RTL ? -gestureState.dx : gestureState.dx;\n        if (this._isSwipingRightFromClosed(gestureState)) {\n            this.props.onOpen && this.props.onOpen();\n            this._animateBounceBack(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n        } else if (this._shouldAnimateRemainder(gestureState)) {\n            if (horizontalDistance < 0) {\n                // Swiped left\n                this.props.onOpen && this.props.onOpen();\n                this._animateToOpenPositionWith(gestureState.vx, horizontalDistance);\n            } else {\n                // Swiped right\n                this.props.onClose && this.props.onClose();\n                this._animateToClosedPosition();\n            }\n        } else {\n            if (this._previousLeft === CLOSED_LEFT_POSITION) {\n                this._animateToClosedPosition();\n            } else {\n                this._animateToOpenPosition();\n            }\n        }\n\n        this.props.onSwipeEnd && this.props.onSwipeEnd();\n    };\n\n    _panResponder = PanResponder.create({\n        onMoveShouldSetPanResponderCapture: this._handleMoveShouldSetPanResponderCapture,\n        onPanResponderGrant: this._handlePanResponderGrant,\n        onPanResponderMove: this._handlePanResponderMove,\n        onPanResponderRelease: this._handlePanResponderEnd,\n        onPanResponderTerminationRequest: this._onPanResponderTerminationRequest,\n        onPanResponderTerminate: this._handlePanResponderEnd,\n        onShouldBlockNativeResponder: (event, gestureState) => false,\n    });\n\n    _previousLeft = CLOSED_LEFT_POSITION;\n    _timeoutID = null;\n\n    state = {\n        currentLeft: new Animated.Value(this._previousLeft),\n        /**\n         * In order to render component A beneath component B, A must be rendered\n         * before B. However, this will cause \"flickering\", aka we see A briefly\n         * then B. To counter this, _isSwipeableViewRendered flag is used to set\n         * component A to be transparent until component B is loaded.\n         */\n        isSwipeableViewRendered: false,\n        rowHeight: null,\n    };\n\n    componentDidMount() {\n        if (this.props.shouldBounceOnMount) {\n            /**\n             * Do the on mount bounce after a delay because if we animate when other\n             * components are loading, the animation will be laggy\n             */\n            this._timeoutID = setTimeout(() => {\n                this._animateBounceBack(ON_MOUNT_BOUNCE_DURATION);\n            }, ON_MOUNT_BOUNCE_DELAY);\n        }\n    }\n\n    UNSAFE_componentWillReceiveProps(nextProps) {\n        /**\n         * We do not need an \"animateOpen(noCallback)\" because this animation is\n         * handled internally by this component.\n         */\n        const isOpen = this.props.isOpen ?? false;\n        const nextIsOpen = nextProps.isOpen ?? false;\n\n        if (isOpen && !nextIsOpen) {\n            this._animateToClosedPosition();\n        }\n    }\n\n    componentWillUnmount() {\n        if (this._timeoutID != null) {\n            clearTimeout(this._timeoutID);\n        }\n    }\n\n    render() {\n        // The view hidden behind the main view\n        let slideOutView;\n        if (this.state.isSwipeableViewRendered && this.state.rowHeight) {\n            slideOutView = (\n                <View style={[styles.slideOutContainer, { height: this.state.rowHeight }]}>\n                    {this.props.slideoutView}\n                </View>\n            );\n        }\n\n        // The swipeable item\n        const swipeableView = (\n            <Animated.View\n                onLayout={this._onSwipeableViewLayout}\n                style={{ transform: [{ translateX: this.state.currentLeft }] }}\n            >\n                {this.props.children}\n            </Animated.View>\n        );\n\n        return (\n            <View {...this._panResponder.panHandlers}>\n                {slideOutView}\n                {swipeableView}\n            </View>\n        );\n    }\n\n    close() {\n        this.props.onClose && this.props.onClose();\n        this._animateToClosedPosition();\n    }\n\n    _onSwipeableViewLayout = event => {\n        this.setState({\n            isSwipeableViewRendered: true,\n            rowHeight: event.nativeEvent.layout.height,\n        });\n    };\n\n    _isSwipingRightFromClosed(gestureState) {\n        const gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n        return this._previousLeft === CLOSED_LEFT_POSITION && gestureStateDx > 0;\n    }\n\n    _swipeFullSpeed(gestureState) {\n        this.state.currentLeft.setValue(this._previousLeft + gestureState.dx);\n    }\n\n    _swipeSlowSpeed(gestureState) {\n        this.state.currentLeft.setValue(\n            this._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR\n        );\n    }\n\n    _isSwipingExcessivelyRightFromClosedPosition(gestureState) {\n        /**\n         * We want to allow a BIT of right swipe, to allow users to know that\n         * swiping is available, but swiping right does not do anything\n         * functionally.\n         */\n        const gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;\n        return (\n            this._isSwipingRightFromClosed(gestureState) && gestureStateDx > RIGHT_SWIPE_THRESHOLD\n        );\n    }\n\n    _animateTo(toValue, duration = SWIPE_DURATION, callback = emptyFunction) {\n        Animated.timing(this.state.currentLeft, {\n            duration,\n            toValue,\n            useNativeDriver: true,\n        }).start(() => {\n            this._previousLeft = toValue;\n            callback();\n        });\n    }\n\n    _animateToOpenPosition() {\n        const maxSwipeDistance = this.props.maxSwipeDistance ?? 0;\n        const directionAwareMaxSwipeDistance = IS_RTL ? -maxSwipeDistance : maxSwipeDistance;\n        this._animateTo(-directionAwareMaxSwipeDistance);\n    }\n\n    _animateToOpenPositionWith(speed, distMoved) {\n        /**\n         * Ensure the speed is at least the set speed threshold to prevent a slow\n         * swiping animation\n         */\n        speed =\n            speed > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD\n                ? speed\n                : HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;\n        const maxSwipeDistance = this.props.maxSwipeDistance ?? 0;\n        /**\n         * Calculate the duration the row should take to swipe the remaining distance\n         * at the same speed the user swiped (or the speed threshold)\n         */\n        const duration = Math.abs((maxSwipeDistance - Math.abs(distMoved)) / speed);\n        const directionAwareMaxSwipeDistance = IS_RTL ? -maxSwipeDistance : maxSwipeDistance;\n        this._animateTo(-directionAwareMaxSwipeDistance, duration);\n    }\n\n    _animateToClosedPosition(duration = SWIPE_DURATION) {\n        this._animateTo(CLOSED_LEFT_POSITION, duration);\n    }\n\n    _animateToClosedPositionDuringBounce = () => {\n        this._animateToClosedPosition(RIGHT_SWIPE_BOUNCE_BACK_DURATION);\n    };\n\n    _animateBounceBack(duration) {\n        /**\n         * When swiping right, we want to bounce back past closed position on release\n         * so users know they should swipe right to get content.\n         */\n        const swipeBounceBackDistance = IS_RTL\n            ? -RIGHT_SWIPE_BOUNCE_BACK_DISTANCE\n            : RIGHT_SWIPE_BOUNCE_BACK_DISTANCE;\n        this._animateTo(\n            -swipeBounceBackDistance,\n            duration,\n            this._animateToClosedPositionDuringBounce\n        );\n    }\n\n    // Ignore swipes due to user's finger moving slightly when tapping\n    _isValidSwipe(gestureState) {\n        const preventSwipeRight = this.props.preventSwipeRight ?? false;\n        if (\n            preventSwipeRight &&\n            this._previousLeft === CLOSED_LEFT_POSITION &&\n            gestureState.dx > 0\n        ) {\n            return false;\n        }\n\n        return Math.abs(gestureState.dx) > HORIZONTAL_SWIPE_DISTANCE_THRESHOLD;\n    }\n\n    _shouldAnimateRemainder(gestureState) {\n        /**\n         * If user has swiped past a certain distance, animate the rest of the way\n         * if they let go\n         */\n        const swipeThreshold = this.props.swipeThreshold ?? DEFAULT_SWIPE_THRESHOLD;\n        return (\n            Math.abs(gestureState.dx) > swipeThreshold ||\n            gestureState.vx > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    slideOutContainer: {\n        bottom: 0,\n        left: 0,\n        position: 'absolute',\n        right: 0,\n        top: 0,\n    },\n});\n\nexport default SwipeableRow;\n"]},"metadata":{},"sourceType":"module"}